---
title: "Cohort spacing algorithm"
author: 
- Rich FitzJohn
- Daniel Falster
date: 2016
output:
  bookdown::html_document2:
    toc: yes
    number_sections: false
---

# Background

As described in the [demography vignette](https://traitecoevo.github.io/plant/articles/demography.html#approximation-of-size-density-distribution-via-the-scm),
the spacing of cohorts can affect the accuracy of integration over the
size-density distribution. `plant` uses an adaptive algorithm to build an 
appropriately spaced cohort schedule with the desired accuracy at every time 
point, using as few cohorts as possible.

The `build_schedule` function takes an
initial vector of introduction times and considers for each cohort
whether removing that cohort causes the error introduced when
integrating two specified functions over the size-density distribution to jump
over the allowable error threshold `schedule_eps`. This
calculation is repeated for every time step in the development of the
patch. A new cohort is introduced immediately prior to any cohort
failing these tests. The dynamics of the patch are
then simulated again and the process is repeated, until all integrations at
all time points have an error below the tolerable limit
`schedule_eps`. Decreasing `schedule_eps` demands higher
accuracy from the solver, and thus increases the number of cohorts being
introduced. Note that we are assessing whether removing an existing cohort
causes the error to jump above the threshold limit, and using this to decide
whether an extra cohort -- in addition to the one used in the test --
should be introduced. Thus, the actual error is likely to
be lower than, but at most equal to, `schedule_eps`.

This vignette shows some details of cohort splitting, most of which happens 
automatically. It's probably not very interesting to most people, only those
interested in knowing how the SCM technique works in detail.  It also uses a lot
of non-exported, non-documented functions from plant so you'll see
a lot of `plant:::` prefixes. 


# Cohort introduction times

<!-- TODO: elaborate on why concentrating concentrating early helps -->

The default cohort introduction times are designed to concentrate
cohort introductions onto earlier times, based on empirical
patterns of cohort refining:

```{r}
library(plant)
library(parallel)

params <- scm_base_parameters("FF16")
patch <- expand_parameters(trait_matrix(0.0825, "lma"), params, mutant = FALSE)

times_default <- patch$cohort_schedule_times[[1]]
plot(times_default, cex=.2, pch=19, ylab="Time (years)", las=1)
```
<!-- TODO: explain how introducing two species together reduces work -->

The actual differences are stepped in order to increase the chance
that cohorts from different species will be introduced at the same
time and reduce the total amount of work being done.

```{r}
plot(diff(times_default), pch=19, cex=.2, ylab="Time difference (years)", las=1)
```


# Seed rain

We can assess the impact of cohort spacing on integration error by examining
the cumulative propagule output (e.g. seed rain) of a patch.

Increasing the number of cohorts is expected to increase integration accuracy
at the expense of more computational effort. We can create more refined schedules
by interleaving points into the existing schedule:


```{r}
interleave <- function(x) {
  n <- length(x)
  xp <- c(x[-n] + diff(x) / 2, NA)
  c(rbind(x, xp))[- 2 * n]
}


times_med <- interleave(times_default)
times_high <- interleave(times_med)
times_xl <- interleave(times_high)

plot(times_default, ylab="Time difference (years)", 
     xlim = c(1, length(times_high)), las=1, pch = 19, cex=.2,)
points(times_med, pch=19, cex=.2, las=1, col = "blue")
points(times_high, pch=19, cex=.2, las=1, col = "red")
```
Each schedule runs for the same duration, but `times_high` has 4x as many cohorts.
Running a patch with each cohort schedule allows us to compare the propagule 
outputs:


```{r}
run_with_times <- function(p, t) {
  p$cohort_schedule_times[[1]] <- t
  
  start <- Sys.time()
  seed_rain <- run_scm(p)$seed_rains
  print(paste("Time to solve:", round(Sys.time() - start, 2)))
  
  return(seed_rain)
}

seed_rain_default <- run_with_times(p, times_default)
seed_rain_med <- run_with_times(p, times_med)
seed_rain_high <- run_with_times(p, times_high)
seed_rain_xl <- run_with_times(p, times_xl)
```
Quadrupling the number of cohorts results in nearly a 6x increase in runtime.

```{r}
plot(x = c(length(times_default), length(times_med), length(times_high), length(times_xl)),
     y = c(seed_rain_default, seed_rain_med, seed_rain_high, seed_rain_xl),
     xlab="Number of cohort introductions", ylab="Seed rain", las=1)
```
Seed rain increases as cohorts are introduced more finely, though at a potentially saturating rate. 



we integrate
two different functions over the size-density distribution, within the function
`run_scm_error`. We then assess how much removing the focal
cohort increases the error in these two integrations. The first
integration, performed by the function `area_leaf_error`, determines
how much the removal of the focal cohort increases the error in the
estimate of the total leaf area in the patch. The second integration,
performed by the function `seed_rain_error`, determines how much
the removal of the focal cohort increases the error in the estimate of the total seed
production from the patch. The relative error in each integration is then
calculated using the `local_error_integration` function.




Consider running the SCM and computing seed rain at the end; this
is one of the key outputs from the model so a reasonable one to
look for differences in.




```{r}
sr <- c(sr_1, sr_2, sr_3)
sr
```

The differences in seed rain are not actually that striking
(perhaps `r signif(100 * diff(range(sr)) / mean(sr), 1)`%) but in
some runs can be more, and the *variation* creates instabilities.

```{r}

```

Where is the fitness difference coming from?

Consider adding a *single* additional cohort at one of the points
along the first vector of times `t1` and computing fitness:

```{r}
insert_time <- function(i, x) {
  j <- seq_len(i)
  c(x[j], (x[i] + x[i+1])/2, x[-j])
}
run_with_insert <- function(i, p, t) {
  run_with_times(p, insert_time(i, t))
}
```

The internal function `plant:::run_scm_error` runs the SCM and
computes errors as the integration proceeds; this helps shed some
light.

<!-- Huh? move below -->

```{r}
i <- seq_len(length(t1) - 1)
res <- unlist(mclapply(i, run_with_insert, p, t1))
tm <- (t1[-1L] + t1[-length(t1)]) / 2
```

The biggest deviations in output seed rain come about half way
through the schedule:

```{r}
plot(i, res - sr_1, xlab="Index", ylab="Seed rain", las=1)
abline(h=0, col="grey")
```

Though because of the compression of early times it's still fairly
early:

```{r}
plot(tm, res - sr_1, xlab="Time (years)", ylab="Seed rain", las=1)
abline(h=0, col="grey")

ebt <- plant:::FF16_SCM(p)
ebt$run()
```

Now look at the contribution of different cohorts to see rain (x axis
log scaled for clarity).  In this case almost all the contribution
comes from early cohorts (this is essentially a single-age stand of
pioneers).  Overlaid on this are the five cohorts with the largest
change in total fitness (biggest difference in red).  The
difference is not coming from seed rain contributions from those
cohorts, which is basically zero, though it is higher than the
surrounding cohorts.

```{r}
plot(t1[-1], ebt$seed_rain_cohort(1)[-1], log="xy",
     xlab="Time (years)", ylab="Seed rain")
j <- order(abs(res - sr_1), decreasing=TRUE)[1:5]
abline(v=tm[j], col=c("red", rep("grey", 4)))
```

Next up, need to work out what the fitness contribution of each
cohort is.

```{r}
dat1 <- run_scm_collect(p)
p2 <- p
p2$cohort_schedule_times[[1]] <- insert_time(j[[1]], t1)
dat2 <- run_scm_collect(p2)
```

Then consider the light environment over time.  This reconstructs
the spline for the light environment for both runs, and computes
canopy openness in both and computes the difference in light
environments.  The resulting image plot is blue in regions where
the refined light environment is lighter (higher canopy openness)
and red in regions where the the light environment is darker in the
refined environment.

```{r}
f <- function(e, h) {
  i <- plant:::Interpolator()
  i$init(e[, 1], e[, 2])
  y <- rep(1, length(h))
  j <- h < i$max
  y[j] <- i$eval(h[j])
  y
}
hmax <- max(dat1$env[[length(dat1$env)]][, "height"])
h <- seq(0, hmax, length.out=201)
y1 <- sapply(dat1$env, f, h)
y2 <- sapply(dat2$env, f, h)[, -(j[[1]] + 1L)]
dy <- t(y2 - y1)
dy[abs(dy) < 1e-10] <- NA
```
ColorBrewer's RdBu

```{r}
cols <- c("#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
          "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC")
pal <- colorRampPalette(cols)(20)
image(dat1$time, h, dy, xlab="Time (years)", ylab="Height (m)", las=1,
      col=pal)
```

Because the differences are mostly manifest in the leaf area, we
monitor error in both the leaf area and in fitness for all cohorts:
(black line indicates the cohort identified as problematic above)

```{r}
dat <- plant:::run_scm_error(p)
image(dat1$time, dat1$time, dat$err$lai[[1]],
      xlab="Patch age (years)", ylab="Introduction time (years)", las=1)
abline(h=t1[j[[1]]])
```

We then run through rounds of refining cohorts until estimated
error has decreased down to an appropriate threshold:

```{r}
p_refined <- build_schedule(p)
sr_refined <- attr(p_refined, "seed_rain_out")
```

Each round, the algorithm looks at the error in the leaf area
calculations and in the fitness calculations and refines the worst
cohorts, repeating as necessary.

```{r}
t_refined <- p_refined$cohort_schedule_times[[1]]
i <- seq_len(length(t_refined) - 1)
res <- unlist(mclapply(i, run_with_insert, p_refined, t_refined))

tm <- (t1[-1L] + t1[-length(t1)]) / 2
```

The problem cohorts are still in about the same place, but are much
less pronounced (and less so if considering relative error)

```{r}
plot(i, res - sr_refined, xlab="Index", ylab="Seed rain", las=1)
abline(h=0, col="grey")

plot(i, res / sr_refined - 1, xlab="Index", ylab="Seed rain", las=1)
```
